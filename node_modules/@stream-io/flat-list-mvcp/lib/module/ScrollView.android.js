function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { useEffect, useRef } from 'react';
import { NativeModules, Platform, ScrollView } from 'react-native';
export const ScrollViewManager = NativeModules.MvcpScrollViewManager;
export default /*#__PURE__*/React.forwardRef((props, forwardedRef) => {
  const {
    maintainVisibleContentPosition: mvcp
  } = props;
  const flRef = useRef(null);
  const isMvcpEnabled = useRef(null);
  const autoscrollToTopThreshold = useRef();
  const minIndexForVisible = useRef();
  const handle = useRef(null);
  const enableMvcpRetries = useRef(0);
  const propAutoscrollToTopThreshold = (mvcp === null || mvcp === void 0 ? void 0 : mvcp.autoscrollToTopThreshold) || -Number.MAX_SAFE_INTEGER;
  const propMinIndexForVisible = (mvcp === null || mvcp === void 0 ? void 0 : mvcp.minIndexForVisible) || 1;
  const hasMvcpChanged = autoscrollToTopThreshold.current !== propAutoscrollToTopThreshold || minIndexForVisible.current !== propMinIndexForVisible;

  const enableMvcp = () => {
    if (!flRef.current) return;
    const scrollableNode = flRef.current.getScrollableNode();
    const enableMvcpPromise = ScrollViewManager.enableMaintainVisibleContentPosition(scrollableNode, autoscrollToTopThreshold.current, minIndexForVisible.current);
    return enableMvcpPromise.then(_handle => {
      handle.current = _handle;
      enableMvcpRetries.current = 0;
    });
  };

  const enableMvcpWithRetries = () => {
    var _enableMvcp;

    autoscrollToTopThreshold.current = propAutoscrollToTopThreshold;
    minIndexForVisible.current = propMinIndexForVisible;
    return (_enableMvcp = enableMvcp()) === null || _enableMvcp === void 0 ? void 0 : _enableMvcp.catch(() => {
      /**
       * enableMaintainVisibleContentPosition from native module may throw IllegalViewOperationException,
       * in case view is not ready yet. In that case, lets do a retry!!
       */
      if (enableMvcpRetries.current < 10) {
        setTimeout(enableMvcp, 10);
        enableMvcpRetries.current += 1;
      }
    });
  };

  const disableMvcp = () => {
    if (!ScrollViewManager || !(handle !== null && handle !== void 0 && handle.current)) {
      return Promise.resolve();
    }

    return ScrollViewManager.disableMaintainVisibleContentPosition(handle.current);
  }; // We can only call enableMaintainVisibleContentPosition once the ref to underlying scrollview is ready.


  const resetMvcpIfNeeded = () => {
    if (!mvcp || Platform.OS !== 'android' || !flRef.current) {
      return;
    }
    /**
     * If the enableMaintainVisibleContentPosition has already been called, then
     * lets not call it again, unless prop values of mvcp changed.
     *
     * This condition is important since `resetMvcpIfNeeded` gets called in refCallback,
     * which gets called by react on every update to list.
     */


    if (isMvcpEnabled.current && !hasMvcpChanged) {
      return;
    }

    isMvcpEnabled.current = true;
    disableMvcp().then(enableMvcpWithRetries);
  };

  const refCallback = ref => {
    flRef.current = ref;
    resetMvcpIfNeeded();

    if (typeof forwardedRef === 'function') {
      forwardedRef(ref);
    } else if (forwardedRef) {
      forwardedRef.current = ref;
    }
  };

  useEffect(() => {
    // disable before unmounting
    return () => {
      disableMvcp();
    };
  }, []);
  return /*#__PURE__*/React.createElement(ScrollView, _extends({}, props, {
    ref: refCallback
  }));
});
//# sourceMappingURL=ScrollView.android.js.map