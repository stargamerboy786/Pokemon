{"version":3,"sources":["FlatList.android.tsx"],"names":["React","useEffect","useRef","FlatList","NativeModules","Platform","ScrollViewManager","MvcpScrollViewManager","forwardRef","props","forwardedRef","maintainVisibleContentPosition","mvcp","flRef","isMvcpEnabled","autoscrollToTopThreshold","minIndexForVisible","handle","enableMvcpRetries","propAutoscrollToTopThreshold","Number","MAX_SAFE_INTEGER","propMinIndexForVisible","hasMvcpChanged","current","enableMvcp","scrollableNode","getScrollableNode","enableMvcpPromise","enableMaintainVisibleContentPosition","then","_handle","enableMvcpWithRetries","catch","setTimeout","disableMvcp","Promise","resolve","disableMaintainVisibleContentPosition","resetMvcpIfNeeded","OS","refCallback","ref"],"mappings":"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","sourcesContent":["import React, { MutableRefObject, useEffect, useRef } from 'react';\nimport { FlatList, FlatListProps, NativeModules, Platform } from 'react-native';\n\nexport const ScrollViewManager = NativeModules.MvcpScrollViewManager;\n\nexport default (React.forwardRef(\n  <T extends any>(\n    props: FlatListProps<T>,\n    forwardedRef:\n      | ((instance: FlatList<T> | null) => void)\n      | MutableRefObject<FlatList<T> | null>\n      | null\n  ) => {\n    const { maintainVisibleContentPosition: mvcp } = props;\n\n    const flRef = useRef<FlatList<T> | null>(null);\n    const isMvcpEnabled = useRef<any>(null);\n    const autoscrollToTopThreshold = useRef<number | null>();\n    const minIndexForVisible = useRef<number>();\n    const handle = useRef<any>(null);\n    const enableMvcpRetries = useRef<number>(0);\n\n    const propAutoscrollToTopThreshold =\n      mvcp?.autoscrollToTopThreshold || -Number.MAX_SAFE_INTEGER;\n    const propMinIndexForVisible = mvcp?.minIndexForVisible || 1;\n    const hasMvcpChanged =\n      autoscrollToTopThreshold.current !== propAutoscrollToTopThreshold ||\n      minIndexForVisible.current !== propMinIndexForVisible;\n    const enableMvcp = () => {\n      if (!flRef.current) return;\n\n      const scrollableNode = flRef.current.getScrollableNode();\n      const enableMvcpPromise = ScrollViewManager.enableMaintainVisibleContentPosition(\n        scrollableNode,\n        autoscrollToTopThreshold.current,\n        minIndexForVisible.current\n      );\n\n      return enableMvcpPromise.then((_handle: number) => {\n        handle.current = _handle;\n        enableMvcpRetries.current = 0;\n      });\n    };\n\n    const enableMvcpWithRetries = () => {\n      return enableMvcp()?.catch(() => {\n        /**\n         * enableMaintainVisibleContentPosition from native module may throw IllegalViewOperationException,\n         * in case view is not ready yet. In that case, lets do a retry!!\n         */\n        if (enableMvcpRetries.current < 10) {\n          setTimeout(enableMvcpWithRetries, 10);\n          enableMvcpRetries.current += 1;\n        }\n      });\n    };\n\n    const disableMvcp: () => Promise<void> = () => {\n      if (!ScrollViewManager || !handle?.current) {\n        return Promise.resolve();\n      }\n\n      return ScrollViewManager.disableMaintainVisibleContentPosition(\n        handle.current\n      );\n    };\n\n    // We can only call enableMaintainVisibleContentPosition once the ref to underlying scrollview is ready.\n    const resetMvcpIfNeeded = (): void => {\n      if (!mvcp || Platform.OS !== 'android' || !flRef.current) {\n        return;\n      }\n\n      /**\n       * If the enableMaintainVisibleContentPosition has already been called, then\n       * lets not call it again, unless prop values of mvcp changed.\n       *\n       * This condition is important since `resetMvcpIfNeeded` gets called in refCallback,\n       * which gets called by react on every update to list.\n       */\n      if (isMvcpEnabled.current && !hasMvcpChanged) {\n        return;\n      }\n      autoscrollToTopThreshold.current = propAutoscrollToTopThreshold;\n      minIndexForVisible.current = propMinIndexForVisible;\n\n      isMvcpEnabled.current = true;\n      disableMvcp().then(enableMvcpWithRetries);\n    };\n\n    const refCallback: (instance: FlatList<T> | null) => void = (ref) => {\n      flRef.current = ref;\n\n      resetMvcpIfNeeded();\n      if (typeof forwardedRef === 'function') {\n        forwardedRef(ref);\n      } else if (forwardedRef) {\n        forwardedRef.current = ref;\n      }\n    };\n\n    useEffect(() => {\n      // disable before unmounting\n      return () => {\n        disableMvcp();\n      };\n    }, []);\n\n    return <FlatList<T> {...props} ref={refCallback} />;\n  }\n) as unknown) as typeof FlatList;\n"]}