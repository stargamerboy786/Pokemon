{"version":3,"sources":["ScrollView.android.tsx"],"names":["ScrollViewManager","NativeModules","MvcpScrollViewManager","React","forwardRef","props","forwardedRef","maintainVisibleContentPosition","mvcp","flRef","isMvcpEnabled","autoscrollToTopThreshold","minIndexForVisible","handle","enableMvcpRetries","propAutoscrollToTopThreshold","Number","MAX_SAFE_INTEGER","propMinIndexForVisible","hasMvcpChanged","current","enableMvcp","scrollableNode","getScrollableNode","enableMvcpPromise","enableMaintainVisibleContentPosition","then","_handle","enableMvcpWithRetries","catch","setTimeout","disableMvcp","Promise","resolve","disableMaintainVisibleContentPosition","resetMvcpIfNeeded","Platform","OS","refCallback","ref"],"mappings":"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","sourcesContent":["import React, { MutableRefObject, useEffect, useRef } from 'react';\nimport {\n  NativeModules,\n  Platform,\n  ScrollView,\n  ScrollViewProps,\n} from 'react-native';\n\nexport const ScrollViewManager = NativeModules.MvcpScrollViewManager;\n\nexport default React.forwardRef(\n  (\n    props: ScrollViewProps,\n    forwardedRef:\n      | ((instance: ScrollView | null) => void)\n      | MutableRefObject<ScrollView | null>\n      | null\n  ) => {\n    const { maintainVisibleContentPosition: mvcp } = props;\n\n    const flRef = useRef<ScrollView | null>(null);\n    const isMvcpEnabled = useRef<any>(null);\n    const autoscrollToTopThreshold = useRef<number | null>();\n    const minIndexForVisible = useRef<number>();\n    const handle = useRef<any>(null);\n    const enableMvcpRetries = useRef<number>(0);\n\n    const propAutoscrollToTopThreshold =\n      mvcp?.autoscrollToTopThreshold || -Number.MAX_SAFE_INTEGER;\n    const propMinIndexForVisible = mvcp?.minIndexForVisible || 1;\n\n    const hasMvcpChanged =\n      autoscrollToTopThreshold.current !== propAutoscrollToTopThreshold ||\n      minIndexForVisible.current !== propMinIndexForVisible;\n\n    const enableMvcp = () => {\n      if (!flRef.current) return;\n\n      const scrollableNode = flRef.current.getScrollableNode();\n      const enableMvcpPromise = ScrollViewManager.enableMaintainVisibleContentPosition(\n        scrollableNode,\n        autoscrollToTopThreshold.current,\n        minIndexForVisible.current\n      );\n\n      return enableMvcpPromise.then((_handle: number) => {\n        handle.current = _handle;\n        enableMvcpRetries.current = 0;\n      });\n    };\n\n    const enableMvcpWithRetries = () => {\n      autoscrollToTopThreshold.current = propAutoscrollToTopThreshold;\n      minIndexForVisible.current = propMinIndexForVisible;\n\n      return enableMvcp()?.catch(() => {\n        /**\n         * enableMaintainVisibleContentPosition from native module may throw IllegalViewOperationException,\n         * in case view is not ready yet. In that case, lets do a retry!!\n         */\n        if (enableMvcpRetries.current < 10) {\n          setTimeout(enableMvcp, 10);\n          enableMvcpRetries.current += 1;\n        }\n      });\n    };\n\n    const disableMvcp: () => Promise<void> = () => {\n      if (!ScrollViewManager || !handle?.current) {\n        return Promise.resolve();\n      }\n\n      return ScrollViewManager.disableMaintainVisibleContentPosition(\n        handle.current\n      );\n    };\n\n    // We can only call enableMaintainVisibleContentPosition once the ref to underlying scrollview is ready.\n    const resetMvcpIfNeeded = (): void => {\n      if (!mvcp || Platform.OS !== 'android' || !flRef.current) {\n        return;\n      }\n\n      /**\n       * If the enableMaintainVisibleContentPosition has already been called, then\n       * lets not call it again, unless prop values of mvcp changed.\n       *\n       * This condition is important since `resetMvcpIfNeeded` gets called in refCallback,\n       * which gets called by react on every update to list.\n       */\n      if (isMvcpEnabled.current && !hasMvcpChanged) {\n        return;\n      }\n\n      isMvcpEnabled.current = true;\n      disableMvcp().then(enableMvcpWithRetries);\n    };\n\n    const refCallback: (instance: ScrollView | null) => void = (ref) => {\n      flRef.current = ref;\n\n      resetMvcpIfNeeded();\n      if (typeof forwardedRef === 'function') {\n        forwardedRef(ref);\n      } else if (forwardedRef) {\n        forwardedRef.current = ref;\n      }\n    };\n\n    useEffect(() => {\n      // disable before unmounting\n      return () => {\n        disableMvcp();\n      };\n    }, []);\n\n    return <ScrollView {...props} ref={refCallback} />;\n  }\n);\n"]}