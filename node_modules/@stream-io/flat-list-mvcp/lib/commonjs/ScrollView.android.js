"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ScrollViewManager = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const ScrollViewManager = _reactNative.NativeModules.MvcpScrollViewManager;
exports.ScrollViewManager = ScrollViewManager;

var _default = /*#__PURE__*/_react.default.forwardRef((props, forwardedRef) => {
  const {
    maintainVisibleContentPosition: mvcp
  } = props;
  const flRef = (0, _react.useRef)(null);
  const isMvcpEnabled = (0, _react.useRef)(null);
  const autoscrollToTopThreshold = (0, _react.useRef)();
  const minIndexForVisible = (0, _react.useRef)();
  const handle = (0, _react.useRef)(null);
  const enableMvcpRetries = (0, _react.useRef)(0);
  const propAutoscrollToTopThreshold = (mvcp === null || mvcp === void 0 ? void 0 : mvcp.autoscrollToTopThreshold) || -Number.MAX_SAFE_INTEGER;
  const propMinIndexForVisible = (mvcp === null || mvcp === void 0 ? void 0 : mvcp.minIndexForVisible) || 1;
  const hasMvcpChanged = autoscrollToTopThreshold.current !== propAutoscrollToTopThreshold || minIndexForVisible.current !== propMinIndexForVisible;

  const enableMvcp = () => {
    if (!flRef.current) return;
    const scrollableNode = flRef.current.getScrollableNode();
    const enableMvcpPromise = ScrollViewManager.enableMaintainVisibleContentPosition(scrollableNode, autoscrollToTopThreshold.current, minIndexForVisible.current);
    return enableMvcpPromise.then(_handle => {
      handle.current = _handle;
      enableMvcpRetries.current = 0;
    });
  };

  const enableMvcpWithRetries = () => {
    var _enableMvcp;

    autoscrollToTopThreshold.current = propAutoscrollToTopThreshold;
    minIndexForVisible.current = propMinIndexForVisible;
    return (_enableMvcp = enableMvcp()) === null || _enableMvcp === void 0 ? void 0 : _enableMvcp.catch(() => {
      /**
       * enableMaintainVisibleContentPosition from native module may throw IllegalViewOperationException,
       * in case view is not ready yet. In that case, lets do a retry!!
       */
      if (enableMvcpRetries.current < 10) {
        setTimeout(enableMvcp, 10);
        enableMvcpRetries.current += 1;
      }
    });
  };

  const disableMvcp = () => {
    if (!ScrollViewManager || !(handle !== null && handle !== void 0 && handle.current)) {
      return Promise.resolve();
    }

    return ScrollViewManager.disableMaintainVisibleContentPosition(handle.current);
  }; // We can only call enableMaintainVisibleContentPosition once the ref to underlying scrollview is ready.


  const resetMvcpIfNeeded = () => {
    if (!mvcp || _reactNative.Platform.OS !== 'android' || !flRef.current) {
      return;
    }
    /**
     * If the enableMaintainVisibleContentPosition has already been called, then
     * lets not call it again, unless prop values of mvcp changed.
     *
     * This condition is important since `resetMvcpIfNeeded` gets called in refCallback,
     * which gets called by react on every update to list.
     */


    if (isMvcpEnabled.current && !hasMvcpChanged) {
      return;
    }

    isMvcpEnabled.current = true;
    disableMvcp().then(enableMvcpWithRetries);
  };

  const refCallback = ref => {
    flRef.current = ref;
    resetMvcpIfNeeded();

    if (typeof forwardedRef === 'function') {
      forwardedRef(ref);
    } else if (forwardedRef) {
      forwardedRef.current = ref;
    }
  };

  (0, _react.useEffect)(() => {
    // disable before unmounting
    return () => {
      disableMvcp();
    };
  }, []);
  return /*#__PURE__*/_react.default.createElement(_reactNative.ScrollView, _extends({}, props, {
    ref: refCallback
  }));
});

exports.default = _default;
//# sourceMappingURL=ScrollView.android.js.map