{"version":3,"sources":["BidirectionalFlatList.tsx"],"names":["styles","StyleSheet","create","indicatorContainer","paddingVertical","width","BidirectionalFlatList","React","forwardRef","props","ref","activityIndicatorColor","autoscrollToTopThreshold","data","enableAutoscrollToTop","FooterLoadingIndicator","HeaderLoadingIndicator","ListHeaderComponent","ListFooterComponent","onEndReached","Promise","resolve","onEndReachedThreshold","onScroll","onStartReached","onStartReachedThreshold","showDefaultLoadingIndicators","onStartReachedInProgress","setOnStartReachedInProgress","onEndReachedInProgress","setOnEndReachedInProgress","onStartReachedTracker","onEndReachedTracker","onStartReachedInPromise","onEndReachedInPromise","maybeCallOnStartReached","length","current","p","finally","then","maybeCallOnEndReached","handleScroll","event","offset","nativeEvent","contentOffset","y","visibleLength","layoutMeasurement","height","contentLength","contentSize","isScrollAtStart","isScrollAtEnd","renderHeaderLoadingIndicator","renderFooterLoadingIndicator","undefined","minIndexForVisible"],"mappings":"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","sourcesContent":["import React, { MutableRefObject, useRef, useState } from 'react';\nimport {\n  ActivityIndicator,\n  FlatList as FlatListType,\n  FlatListProps,\n  ScrollViewProps,\n  StyleSheet,\n  View,\n} from 'react-native';\nimport { FlatList } from '@stream-io/flat-list-mvcp';\n\nconst styles = StyleSheet.create({\n  indicatorContainer: {\n    paddingVertical: 5,\n    width: '100%',\n  },\n});\n\nexport type Props<T> = Omit<\n  FlatListProps<T>,\n  'maintainVisibleContentPosition'\n> & {\n  /**\n   * Called once when the scroll position gets close to end of list. This must return a promise.\n   * You can `onEndReachedThreshold` as distance from end of list, when this function should be called.\n   */\n  onEndReached: () => Promise<void>;\n  /**\n   * Called once when the scroll position gets close to begining of list. This must return a promise.\n   * You can `onStartReachedThreshold` as distance from beginning of list, when this function should be called.\n   */\n  onStartReached: () => Promise<void>;\n  /** Color for inline loading indicator */\n  activityIndicatorColor?: string;\n  /**\n   * Enable autoScrollToTop.\n   * In chat type applications, you want to auto scroll to bottom, when new message comes it.\n   */\n  enableAutoscrollToTop?: boolean;\n  /**\n   * If `enableAutoscrollToTop` is true, the scroll threshold below which auto scrolling should occur.\n   */\n  autoscrollToTopThreshold?: number;\n  /** Scroll distance from beginning of list, when onStartReached should be called. */\n  onStartReachedThreshold?: number;\n  /**\n   * Scroll distance from end of list, when onStartReached should be called.\n   * Please note that this is different from onEndReachedThreshold of FlatList from react-native.\n   */\n  onEndReachedThreshold?: number;\n  /** If true, inline loading indicators will be shown. Default - true */\n  showDefaultLoadingIndicators?: boolean;\n  /** Custom UI component for header inline loading indicator */\n  HeaderLoadingIndicator?: React.ComponentType;\n  /** Custom UI component for footer inline loading indicator */\n  FooterLoadingIndicator?: React.ComponentType;\n  /** Custom UI component for header indicator of FlatList. Only used when `showDefaultLoadingIndicators` is false */\n  ListHeaderComponent?: React.ComponentType;\n  /** Custom UI component for footer indicator of FlatList. Only used when `showDefaultLoadingIndicators` is false */\n  ListFooterComponent?: React.ComponentType;\n};\n/**\n * Note:\n * - `onEndReached` and `onStartReached` must return a promise.\n * - `onEndReached` and `onStartReached` only get called once, per content length.\n * - maintainVisibleContentPosition is fixed, and can't be modified through props.\n * - doesn't accept `ListFooterComponent` via prop, since it is occupied by `FooterLoadingIndicator`.\n *    Set `showDefaultLoadingIndicators` to use `ListFooterComponent`.\n * - doesn't accept `ListHeaderComponent` via prop, since it is occupied by `HeaderLoadingIndicator`\n *    Set `showDefaultLoadingIndicators` to use `ListHeaderComponent`.\n */\nexport const BidirectionalFlatList = (React.forwardRef(\n  <T extends any>(\n    props: Props<T>,\n    ref:\n      | ((instance: FlatListType<T> | null) => void)\n      | MutableRefObject<FlatListType<T> | null>\n      | null\n  ) => {\n    const {\n      activityIndicatorColor = 'black',\n      autoscrollToTopThreshold = 100,\n      data,\n      enableAutoscrollToTop,\n      FooterLoadingIndicator,\n      HeaderLoadingIndicator,\n      ListHeaderComponent,\n      ListFooterComponent,\n      onEndReached = () => Promise.resolve(),\n      onEndReachedThreshold = 10,\n      onScroll,\n      onStartReached = () => Promise.resolve(),\n      onStartReachedThreshold = 10,\n      showDefaultLoadingIndicators = true,\n    } = props;\n    const [onStartReachedInProgress, setOnStartReachedInProgress] = useState(\n      false\n    );\n    const [onEndReachedInProgress, setOnEndReachedInProgress] = useState(false);\n\n    const onStartReachedTracker = useRef<Record<number, boolean>>({});\n    const onEndReachedTracker = useRef<Record<number, boolean>>({});\n\n    const onStartReachedInPromise = useRef<Promise<void> | null>(null);\n    const onEndReachedInPromise = useRef<Promise<void> | null>(null);\n\n    const maybeCallOnStartReached = () => {\n      // If onStartReached has already been called for given data length, then ignore.\n      if (data?.length && onStartReachedTracker.current[data.length]) {\n        return;\n      }\n\n      if (data?.length) {\n        onStartReachedTracker.current[data.length] = true;\n      }\n\n      setOnStartReachedInProgress(true);\n      const p = () => {\n        return new Promise<void>((resolve) => {\n          onStartReachedInPromise.current = null;\n          setOnStartReachedInProgress(false);\n          resolve();\n        });\n      };\n\n      if (onEndReachedInPromise.current) {\n        onEndReachedInPromise.current.finally(() => {\n          onStartReachedInPromise.current = onStartReached().then(p);\n        });\n      } else {\n        onStartReachedInPromise.current = onStartReached().then(p);\n      }\n    };\n\n    const maybeCallOnEndReached = () => {\n      // If onEndReached has already been called for given data length, then ignore.\n      if (data?.length && onEndReachedTracker.current[data.length]) {\n        return;\n      }\n\n      if (data?.length) {\n        onEndReachedTracker.current[data.length] = true;\n      }\n\n      setOnEndReachedInProgress(true);\n      const p = () => {\n        return new Promise<void>((resolve) => {\n          onStartReachedInPromise.current = null;\n          setOnEndReachedInProgress(false);\n          resolve();\n        });\n      };\n\n      if (onStartReachedInPromise.current) {\n        onStartReachedInPromise.current.finally(() => {\n          onEndReachedInPromise.current = onEndReached().then(p);\n        });\n      } else {\n        onEndReachedInPromise.current = onEndReached().then(p);\n      }\n    };\n\n    const handleScroll: ScrollViewProps['onScroll'] = (event) => {\n      // Call the parent onScroll handler, if provided.\n      onScroll?.(event);\n\n      const offset = event.nativeEvent.contentOffset.y;\n      const visibleLength = event.nativeEvent.layoutMeasurement.height;\n      const contentLength = event.nativeEvent.contentSize.height;\n\n      // Check if scroll has reached either start of end of list.\n      const isScrollAtStart = offset < onStartReachedThreshold;\n      const isScrollAtEnd =\n        contentLength - visibleLength - offset < onEndReachedThreshold;\n\n      if (isScrollAtStart) {\n        maybeCallOnStartReached();\n      }\n\n      if (isScrollAtEnd) {\n        maybeCallOnEndReached();\n      }\n    };\n\n    const renderHeaderLoadingIndicator = () => {\n      if (!showDefaultLoadingIndicators) {\n        if (ListHeaderComponent) {\n          return <ListHeaderComponent />;\n        } else {\n          return null;\n        }\n      }\n\n      if (!onStartReachedInProgress) return null;\n\n      if (HeaderLoadingIndicator) {\n        return <HeaderLoadingIndicator />;\n      }\n\n      return (\n        <View style={styles.indicatorContainer}>\n          <ActivityIndicator size={'small'} color={activityIndicatorColor} />\n        </View>\n      );\n    };\n\n    const renderFooterLoadingIndicator = () => {\n      if (!showDefaultLoadingIndicators) {\n        if (ListFooterComponent) {\n          return <ListFooterComponent />;\n        } else {\n          return null;\n        }\n      }\n\n      if (!onEndReachedInProgress) return null;\n\n      if (FooterLoadingIndicator) {\n        return <FooterLoadingIndicator />;\n      }\n\n      return (\n        <View style={styles.indicatorContainer}>\n          <ActivityIndicator size={'small'} color={activityIndicatorColor} />\n        </View>\n      );\n    };\n\n    return (\n      <>\n        <FlatList<T>\n          {...props}\n          ref={ref}\n          progressViewOffset={50}\n          ListHeaderComponent={renderHeaderLoadingIndicator}\n          ListFooterComponent={renderFooterLoadingIndicator}\n          onEndReached={null}\n          onScroll={handleScroll}\n          maintainVisibleContentPosition={{\n            autoscrollToTopThreshold: enableAutoscrollToTop\n              ? autoscrollToTopThreshold\n              : undefined,\n            minIndexForVisible: 1,\n          }}\n        />\n      </>\n    );\n  }\n) as unknown) as BidirectionalFlatListType;\n\ntype BidirectionalFlatListType = <T extends any>(\n  props: Props<T>\n) => React.ReactElement;\n"]}